/*
 * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.rhizomedb.ir

import org.jetbrains.kotlin.backend.common.extensions.IrPluginContext
import org.jetbrains.kotlin.backend.common.lower.createIrBuilder
import org.jetbrains.kotlin.ir.IrElement
import org.jetbrains.kotlin.ir.builders.*
import org.jetbrains.kotlin.ir.builders.declarations.addConstructor
import org.jetbrains.kotlin.ir.declarations.IrClass
import org.jetbrains.kotlin.ir.declarations.IrConstructor
import org.jetbrains.kotlin.ir.declarations.IrDeclarationOrigin.GeneratedByPlugin
import org.jetbrains.kotlin.ir.expressions.IrDelegatingConstructorCall
import org.jetbrains.kotlin.ir.expressions.impl.IrClassReferenceImpl
import org.jetbrains.kotlin.ir.expressions.impl.IrDelegatingConstructorCallImpl
import org.jetbrains.kotlin.ir.symbols.UnsafeDuringIrConstructionAPI
import org.jetbrains.kotlin.ir.types.*
import org.jetbrains.kotlin.ir.types.impl.makeTypeProjection
import org.jetbrains.kotlin.ir.util.*
import org.jetbrains.kotlin.ir.visitors.IrElementVisitorVoid
import org.jetbrains.kotlin.ir.visitors.acceptChildrenVoid
import org.jetbrains.kotlin.types.Variance
import org.jetbrains.rhizomedb.fir.RhizomedbAnnotations
import org.jetbrains.rhizomedb.fir.RhizomedbPluginKey
import org.jetbrains.rhizomedb.fir.RhizomedbSymbolNames

@OptIn(UnsafeDuringIrConstructionAPI::class)
class TransformerForCompanionGenerator(private val context: IrPluginContext) : IrElementVisitorVoid {
    private val irFactory = context.irFactory
    private val irBuiltIns = context.irBuiltIns

    override fun visitElement(element: IrElement) {
        element.acceptChildrenVoid(this)
    }

    override fun visitClass(declaration: IrClass) {
        declaration.acceptChildrenVoid(this)
        if (!declaration.isCompanion) {
            return
        }

        val origin = declaration.origin
        if (origin is GeneratedByPlugin && origin.pluginKey == RhizomedbPluginKey) {
            // Companion object fully generated by compiler plugin
            require(declaration.primaryConstructor == null) { "Generated companion object should not have a primary constructor" }
            declaration.addConstructor { isPrimary = true }.also {
                it.body = irBuiltIns.createIrBuilder(it.symbol).run {
                    irBlockBody {
                        +irDelegatingEntityTypeCall(it)
                    }
                }
            }
        } else {
            val entityClass = declaration.parentClassOrNull?.parentClassOrNull ?: return
            if (!entityClass.hasAnnotation(RhizomedbAnnotations.generatedEntityTypeClassId)) {
                return
            }

            // Companion object written by user, but EntityType superclass generated by compiler plugin
            val constructor = declaration.primaryConstructor ?: return
            val statements = constructor.body?.statements ?: return
            constructor.body = irBuiltIns.createIrBuilder(constructor.symbol).irBlockBody {
                statements.forEach { statement ->
                    if (statement is IrDelegatingConstructorCall) {
                        require(statement.type == irBuiltIns.anyType) { "Unexpected delegating constructor call: ${statement.dump()}" }
                        +irDelegatingEntityTypeCall(constructor)
                    } else {
                        +statement
                    }
                }
            }
        }
    }

    /**
     * Generate EntityType constructor call for MyEntity.Companion constructor
     *
     * Initial sources:
     * ```
     * package org.jetbrains.fleet
     *
     * @GeneratedEntityType(Durable::class, MyMixin::class)
     * data class MyEntity(override val eid: EID) : Entity
     * ```
     *
     * Expected after FIR
     * ```
     * package org.jetbrains.fleet
     *
     * @GeneratedEntityType(Durable::class, MyMixin::class)
     * data class MyEntity(override val eid: EID) : Entity {
     *   companion object : EntityType<MyEntity>
     * }
     * ```
     *
     * Generation result (only delegated constructor call generated)
     * ```
     * package org.jetbrains.fleet
     *
     * @GeneratedEntityType(Durable::class, MyMixin::class)
     * data class MyEntity(override val eid: EID) : Entity {
     *   companion object : EntityType<MyEntity>(
     *     ident = "org.jetbrains.fleet.MyEntity",
     *     module = entityModule(MyEntity::class),
     *     reify = ::MyEntity,
     *     mixins = arrayOf(Durable, MyMixin)
     *   )
     * }
     * ```
     */
    private fun IrBuilderWithScope.irDelegatingEntityTypeCall(declaration: IrConstructor): IrDelegatingConstructorCall {
        val companionIrType = requireNotNull(declaration.returnType as? IrSimpleType) { "Unexpected return type: ${declaration.returnType.render()}" }
        val entityClass = requireNotNull(declaration.parentClassOrNull?.parentClassOrNull) { "Unexpected parent class: ${declaration.parentClassOrNull?.render()}" }
        val entityIrType = entityClass.typeWith()

        val entityTypeIrType = requireNotNull(companionIrType.classifier.superTypes().firstOrNull {
            it.classFqName == RhizomedbSymbolNames.entityTypeClassId.asSingleFqName()
        }) { "EntityType type not found" }

        val entityConstructor = requireNotNull(entityClass.constructors.firstOrNull {
            it.valueParameters.singleOrNull()?.type == irBuiltIns.intType
        }) { "EntityType constructor not found" }
        val entityTypeConstructor = requireNotNull(entityTypeIrType.getClass()?.primaryConstructor?.symbol) { "EntityType constructor not found" }

        // abstract class EntityType<E : Entity>(
        //  ident: String,
        //  module: String,
        //  internal val reify: (EID) -> E,
        //  vararg mixins: Mixin<in E>
        //)
        val delegatingEntityTypeCall = IrDelegatingConstructorCallImpl.fromSymbolOwner(
            SYNTHETIC_OFFSET, SYNTHETIC_OFFSET,
            entityTypeIrType, entityTypeConstructor,
        ).apply {
            // Type arguments
            // <E : Entity>
            putTypeArgument(0, entityIrType)
        }.apply {
            // Value arguments
            // ident: String = MyEntity::class.qualifiedName
            val entityFqName = requireNotNull(entityClass.classId?.asSingleFqName()?.asString()) { "Unexpected entity class: ${entityClass.render()}" }
            val indent = entityFqName.toIrConst(irBuiltIns.stringType)
            putValueArgument(0, indent)

            // module: String = entityModule(MyEntity::class)
            val entityModuleCall = irCall(irBuiltIns.entityModuleFunction).apply {
                val getClass = IrClassReferenceImpl(
                    -1, -1, context.irBuiltIns.kClassClass.starProjectedType, context.irBuiltIns.kClassClass, entityIrType
                )
                putValueArgument(0, getClass)
            }
            putValueArgument(1, entityModuleCall)

            // reify: (EID) -> E = ::MyEntity
            val constructorRefType = irBuiltIns.functionN(1).typeWith(irBuiltIns.intType, entityIrType)
            val constructorRef = irFunctionReference(
                type = constructorRefType,
                symbol = entityConstructor.symbol
            )
            putValueArgument(2, constructorRef)

            // vararg mixins: Mixin<in E> = arrayOf(Durable, MyMixin)
            val elementType = irBuiltIns.mixinType.typeWithArguments(listOf(makeTypeProjection(entityIrType, Variance.IN_VARIANCE)))
            val vararg = irVararg(elementType, emptyList())
            putValueArgument(3, vararg)
        }

        return delegatingEntityTypeCall
    }
}
